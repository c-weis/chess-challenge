using ChessChallenge.API;
using System;
using System.Collections.Generic;
using System.Linq;

public class MyBot : IChessBot
{
    static int ExplorationDepth = 3;
    static int ExtraCaptureDepth = 15;
    static float CheckMateValue = 1e6f; // Large, but finite value for checkmate.
    public Computation LastComputation = new Computation(0,0);
    public int BoardEvaluationCounter {get; private set;} = 0;
    public int RunningAverageBoardEvaluations {get; private set;} = -1;
    static Random rnd = new Random();

    public Move Think(Board board, Timer timer)
    {
        // Reset counter of board evaluations
        BoardEvaluationCounter = 0;

        var bestMove = BestMoveRecursive(board, 3).Item1;

        RunningAverageBoardEvaluations = (9*RunningAverageBoardEvaluations + BoardEvaluationCounter)/10;

        return bestMove;
    }

    public (Move, float) BestMoveRecursive(Board board, int depth){
        if (board.IsInCheckmate()) return (default, float.NegativeInfinity);
        if (board.IsDraw()) return (default, 0);
        if (depth == 0) return (default, EvaluateAverageRandomCaptureLine(board, 2, 9));

        float max = float.NegativeInfinity;
        Move bestMove = board.GetLegalMoves()[0];
        foreach(var move in board.GetLegalMoves()){
            board.MakeMove(move);
            var eval = - BestMoveRecursive(board, depth-1).Item2;
            if(eval > max) {
                max = eval;
                bestMove = move;
            }
            board.UndoMove(move);
        }

        return (bestMove, max);
    }

    static List<float> values = new (){0.0f, 1.0f, 3.0f, 3.3f, 5.0f, 9.0f, 100.0f};

    private float EvaluateAverageRandomCaptureLine(Board board, int depth, int samples) {
        var evals = new List<float>();
        for(int i=0; i<samples; i++) {
            evals.Add(EvaluateRandomCaptureLine(board, depth));
        }
        return evals.Average();
    }
    
    private float EvaluateRandomCaptureLine(Board board, int depth) {
        var captures = board.GetLegalMoves(0 == depth%2); 

        // if depth is 0 or the position has no captures it's "quiet", so we evaluate the board
        if (depth == 0 || !captures.Any()) return EvaluateBoard(board);

        // otherwise pick a random capture
        var randomCapture = captures[rnd.Next(captures.Count())];
        board.MakeMove(randomCapture);
        float eval = EvaluateRandomCaptureLine(board, depth-1);
        board.UndoMove(randomCapture);

        return -eval;
    }

    private float EvaluateBoard(Board board) {
        var sum = 0.0f;
        var pieceLists = board.GetAllPieceLists();
        foreach(var pieceList in pieceLists){
            var multiplier = pieceList.IsWhitePieceList ? 1.0f : -1.0f;
            sum += multiplier * pieceList.Count * values[(int)pieceList.TypeOfPieceInList];
        }

        // Add pseudo-randomness
        sum += 01e-10f * ((int) board.ZobristKey % 1000);
        
        return Multiplier(board) * sum;
    }
    private float Multiplier(Board board){
        return board.IsWhiteToMove ? 1.0f : -1.0f;
    }
}


public struct Computation {

    public List<Move> Line;
    public float Evaluation {get; set;}
    public int Depth {get; set; }
    public int ExtraDepth {get; set; }
    public readonly Move BestMove => Line.LastOrDefault(Move.NullMove);

    public Computation(float evaluation, int depth){
        Evaluation = evaluation;
        Depth = Math.Min(depth,0);
        ExtraDepth = Math.Max(-depth,0);
        Line = new List<Move>();
    }

    public Computation Extend(Move move, int currentDepth) {
        var extendedEval = new Computation(-Evaluation, currentDepth)
        {
            ExtraDepth = ExtraDepth,
            Line = new(Line) // copy line
        };
        extendedEval.Line.Add(move); //add new move
        extendedEval.Depth = currentDepth;
        return extendedEval;
    }
}